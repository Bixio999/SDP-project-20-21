package dronazon;

import java.util.Random;

import droneNetwork.proto.DroneNetworkServiceOuterClass.Delivery;
import org.eclipse.paho.client.mqttv3.MqttClient;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;

/**
 * Dronazon class that models the orders publisher for the application.
 *
 * Generate a new order every 5 seconds, with random created positions on the smart city for retrieve
 * and delivery locations. They are then packed into a Delivery class (generated by Protocol Buffer)
 * and sent as payload of the message.
 *
 * The locations are implemented as strings, composed by the two coords separated by the character ":".
 *
 * The MQTT topic where the class publishes is "dronazon/smartcity/orders".
 *
 * The class is composed just by the main method.
 */
public class Dronazon {
    
    public static void main(String[] args) {

        // MQTT client object
        MqttClient client;

        // IP address of the MQTT Broker
        String broker = "tcp://localhost:1883";

        // The MQTT client ID randomly generated by the offered method of MqttClient class
        String clientId = MqttClient.generateClientId();

        // The topic where the messages must be published
        String topic = "dronazon/smartcity/orders";

        // Quality of Service set to 2, in order to assert the delivery to broker
        int qos = 2;

        // Counter for ID assignment of new deliveries
        long progressiveId = 0;

        // Random number generator used for location coords of the order
        Random rand = new Random();

        try {
            // Instantiate the MQTT classes for connection
            client = new MqttClient(broker, clientId);
            MqttConnectOptions options = new MqttConnectOptions();
            options.setCleanSession(true);

            // Connect the client to the broker
            System.out.println(clientId + " Connecting Broker " + broker);
            client.connect(options);
            System.out.println(clientId + " Connected");

            // Produce orders until connection to broker is active
            while(client.isConnected())
            {
                // Generate the package retrieve location.
                String packageRetrieve = rand.nextInt(10) + ":" + rand.nextInt(10);
                // Generate the package delivery location.
                String packageDelivery = rand.nextInt(10) + ":" + rand.nextInt(10);

                // Assert the two location doesn't coincide, and change che delivery location until they are different
                while(packageDelivery.equals(packageRetrieve))
                    packageDelivery = rand.nextInt(10) + ":" + rand.nextInt(10);

                // Build the delivery object
                Delivery delivery = Delivery.newBuilder().setDeliveryId(progressiveId).setFrom(packageRetrieve).setTo(packageDelivery).build();
                // Increase the progressive ID variable for the next order
                progressiveId++;

                // Create the message payload by getting the byte array from delivery object
                byte[] payload = delivery.toByteArray();

                // Create the MQTT message with the payload
                MqttMessage message = new MqttMessage(payload);
                // Assign the QOS
                message.setQos(qos);

                // Publish the message into topic
                System.out.println(clientId + " Publishing message...");
                client.publish(topic, message);
                System.out.println(clientId + " Message published! Order id: " + delivery.getDeliveryId());

                // Sleep for 5 seconds and then generate a new order
                Thread.sleep(5000);
            }
        }
        // Catch the eventual MQTT Exceptions and print to console
        catch (MqttException me ) {
            System.out.println("reason " + me.getReasonCode());
            System.out.println("msg " + me.getMessage());
            System.out.println("loc " + me.getLocalizedMessage());
            System.out.println("cause " + me.getCause());
            System.out.println("excep " + me);
            me.printStackTrace();
        }
        // Print any other exception that may be thrown
        catch (Exception e) {
            e.printStackTrace();
        }
    }
}
